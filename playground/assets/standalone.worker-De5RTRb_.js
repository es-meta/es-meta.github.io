let u=null,{resolve:o,promise:t}=Promise.withResolvers();const x=async(r,s)=>{switch(r){case"spec/func":return JSON.parse((await t).spec_func());case"meta/version":return JSON.parse((await t).meta_version());case"meta/iter":return 1;case"meta/debugString":return"";case"spec/version":return JSON.parse((await t).spec_version());default:throw i(r)}},J=async(r,s,e)=>{switch(s){case"breakpoint":switch(r){case"POST":return JSON.parse((await t).breakpoint_add(e!==void 0?JSON.stringify(e):void 0));case"DELETE":return JSON.parse((await t).breakpoint_remove(e!==void 0?JSON.stringify(e):void 0));case"PUT":return JSON.parse((await t).breakpoint_toggle(e!==void 0?JSON.stringify(e):void 0));default:throw i(s)}case"exec/run":return JSON.parse((await t).exec_run(e!==void 0?JSON.stringify(e):void 0));case"exec/resumeFromIter":return JSON.parse((await t).exec_resumeFromIter(e!==void 0?JSON.stringify(e):void 0));case"exec/backToProvenance":return JSON.parse((await t).exec_backToProvenance(e!==void 0?JSON.stringify(e):void 0));case"exec/specStep":return JSON.parse((await t).exec_step(a(e)));case"exec/specStepOver":return JSON.parse((await t).exec_stepOver(a(e)));case"exec/specStepOut":return JSON.parse((await t).exec_stepOut(a(e)));case"exec/specContinue":return JSON.parse((await t).exec_continue());case"exec/specRewind":return JSON.parse((await t).exec_rewind());case"exec/specStepBack":return JSON.parse((await t).exec_stepBack(a(e)));case"exec/specStepBackOut":return JSON.parse((await t).exec_stepBackOut(a(e)));case"exec/specStepBackOver":return JSON.parse((await t).exec_stepBackOver(a(e)));case"exec/esAstStep":return JSON.parse((await t).exec_esAstStep(a(e)));case"exec/esStatementStep":return JSON.parse((await t).exec_esStatementStep(a(e)));case"exec/esStepOver":return JSON.parse((await t).exec_esStepOver(a(e)));case"exec/esStepOut":return JSON.parse((await t).exec_esStepOut(a(e)));case"exec/irStep":return JSON.parse((await t).exec_irStep(a(e)));case"exec/irStepOver":return JSON.parse((await t).exec_irStepOver(a(e)));case"exec/irStepOut":return JSON.parse((await t).exec_irStepOut(a(e)));case"exec/stepCntPlus":return JSON.parse((await t).exec_stepCntPlus(a(e)));case"exec/stepCntMinus":return JSON.parse((await t).exec_stepCntMinus(a(e)));case"exec/instCntPlus":return JSON.parse((await t).exec_instCntPlus(a(e)));case"exec/instCntMinus":return JSON.parse((await t).exec_instCntMinus(a(e)));default:throw i(s)}};self.onmessage=async r=>{const{id:s,type:e,endpoint:p,data:n}=r.data;try{let c;switch(e){case"META":u=n,await import("./main-CsiOyw-x.js").then(async S=>o(await S.StandaloneDebugger.buildFrom(u,w=>{self.postMessage({id:void 0,type:"RATE",data:w})}))),await t;break;case"GET":c=await x(p,n);break;case"POST":case"PUT":case"DELETE":c=await J(e,p,n);break;default:throw new Error(`Unsupported request type: ${e}`)}self.postMessage({id:s,success:!0,data:c})}catch(c){console.error("error",c),self.postMessage({id:s,success:!1,error:c.message})}};function a(r){return typeof r=="boolean"?r:(console.error("Invalid boolean value:",r),!1)}function i(r){return new Error(`Unknown API endpoint ${r}`)}
